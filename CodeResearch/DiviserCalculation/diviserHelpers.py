import numpy as np
from numba import jit, prange
from rtree import index
from sortedcontainers import SortedDict

@jit(nopython=True)
def GetValuedTarget(target, c1, c1p, c2p):

    res = np.zeros(len(target))
    for iObject in range(0, len(target)):
        res[iObject] = c1p if target[iObject] == c1 else c2p

    return res

def GetSortedDict(dataSet):
    res = []
    nFeatures = dataSet.shape[1]
    nObjects = dataSet.shape[0]

    for iFeature in range(0, nFeatures):
        curDict = SortedDict()
        res.append(curDict)

        for iObject in range(0, nObjects):
            v = -dataSet[iObject, iFeature]
            if v not in curDict:
                curDict[v] = {iObject}
            else:
                curDict[v].add(iObject)

    return res

@jit(nopython=True)
def getSortedSet(dataSet):

    nFeatures = dataSet.shape[1]
    nObjects = dataSet.shape[0]

    res = np.zeros((nObjects, nFeatures), dtype=int)

    for iFeature in prange(0, nFeatures):
        sortedObjects = np.argsort(dataSet[:, iFeature])
        res[:, iFeature] = sortedObjects

    return res

def GetSortedDictByIndex(sortedIdx, objects):
    res = []
    nFeatures = objects.shape[1]
    nObjects = objects.shape[0]

    for iFeature in range(0, nFeatures):
        curDict = dict()
        res.append(curDict)

        for iObject in range(nObjects - 1, -1, -1):
            origIdx = sortedIdx[iObject, iFeature]
            curDict[origIdx] = objects[origIdx, iFeature]

    return res

def GetSortedDictList(dataSet):
    res = []
    nFeatures = dataSet.shape[1]
    nObjects = dataSet.shape[0]

    for iFeature in range(0, nFeatures):
        curDict = SortedDict()
        res.append(curDict)

        for iObject in range(0, nObjects):
            v = -dataSet[iObject, iFeature]
            if v not in curDict:
                curDict[v] = {iObject}
            else:
                curDict[v].add(iObject)

    return res

def getIdx(dataSet, id):
    nObjects = dataSet.shape[0]
    nFeatures = dataSet.shape[1]

    p = index.Property()
    p.dimension = nFeatures

    capacity = max(100, nObjects)

    p.index_capacity = capacity
    p.index_pool_capacity = capacity
    p.point_pool_capacity = capacity
    p.buffering_capacity = capacity
    p.leaf_capacity = capacity

    idx = index.Index(properties=p)
    idx.properties.dimension = nFeatures

    points = np.zeros((nObjects, 2*nFeatures))
    points[:, 0:nFeatures] = dataSet
    points[:, nFeatures:2*nFeatures] = dataSet

    #s1 = time.time()
    for iObject in range(0, nObjects):
        #print(iObject)
        idx.insert(id[iObject], points[iObject, :])
    #e1 = time.time()
    #print('Generated by {:}'.format(e1 - s1))

    return idx

def GetPowerOfSet(sortedNegDataSet):
    powers = np.zeros(len(sortedNegDataSet))

    for idx in range(0, len(sortedNegDataSet)):
        powers[idx] = len(sortedNegDataSet[idx])

    return powers

def getPointsUnderDiviser(idx, currentDiviser, basePoint):

    nFeatures = len(currentDiviser)
    query = np.zeros(2 * nFeatures)

    query[0:nFeatures] = basePoint
    query[nFeatures:2*nFeatures] = currentDiviser

    res = list(idx.intersection(query))

    return len(res)

def getPointsIdxUnderDiviser(idx, currentDiviser, basePoint):

    nFeatures = len(currentDiviser)
    query = np.zeros(2 * nFeatures)

    query[0:nFeatures] = basePoint
    query[nFeatures:2*nFeatures] = currentDiviser

    return set(idx.intersection(query))

def getBestStartDiviser(sortedNegValues, positiveScore, positiveCount, positiveIdx, basePoint):
    bestDiviser = sortedNegValues[- 1, :]

    positivePointsUnderDiviser = getPointsUnderDiviser(positiveIdx, bestDiviser, basePoint)
    #positivePointsUnderDiviser = getPointsBeforeDiviserIntersection(sortedPosValues, sortedPosIdx, bestDiviser)
    bestScore = (positiveCount - positivePointsUnderDiviser) * positiveScore

    return bestDiviser, bestScore

@jit(nopython=True)
def prepareDataSet(dataSet):
    nFeatures = dataSet.shape[1]

    usefulFeatures = np.zeros(nFeatures)

    for iFeature in range(0, nFeatures):
        uf = np.unique(dataSet[:, iFeature])
        if len(uf) != 1:
            usefulFeatures[iFeature] = 1

    idx = np.nonzero(usefulFeatures)[0]
    return dataSet[:, idx]
